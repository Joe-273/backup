## 浏览器缓存的基本原理

1. 浏览器每次发起请求，都会现在浏览器的缓存中查找该请求的结果以及缓存标识。
2. 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器的缓存中。

### 缓存的位置

浏览器缓存的位置有四种，并且各自有优先级，当依次查找缓存且都没有命中缓存的时候，才会去请求网络。

1. Service Worker
    > Service Worker是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。

2. Memory Cache

3. Disk Cache

4. Push Cache

## 按照缓存的类型分类

### 强制缓存

强制缓存的含义是，当客户端请求后，会先访问缓存数据库看看缓存是否已经存在。如果存在则直接返回缓存内容；不存在才会发送真实请求。

强制缓存直接减少请求数，是提升最大的缓存策略。如果考虑使用缓存来优化网页性能的话，强制缓存应该是优先被考虑的。

能够造成强缓存的字段有：
- `Expires`
    > 这是 HTTP/1.0 的字段，标识缓存到期时间，是一个绝对的时间（当前时间+缓存时间）  
    >
    > 缺点：
    > 1. 由于这个字段是一个绝对时间，用户可能会修改本地时间，从而导致浏览器判断缓存失效。  
    >
    > 2. 写法太复杂。表示时间的字符串多个空格或者少个字母等，都会导致变为非法属性而失效。
    ```txt
    Expires: Thu, 10 Nov 2017 08:45:11 GMT
    ```
- `Cache-control`
    > 知道了Expires的缺点之后，在 HTTP/1.1 后增加了该字段。表示资源缓存的最大有效时间，在这段时间内，客户端不需要向服务器发送请求。
    >
    > Cache-control的一些常用字段：
    > 1. max-age：最大有效时间。
    >
    > 2. must-revalidate：如果超出了max-age的时间，浏览器必须向服务器发送请求，验证资源是否有效。
    >
    > 3. no-cache：能够在客户端缓存资源，但每次都必须去跟服务器做一个新鲜度校验，来决定是向服务器请求新的资源（200）还是使用客户端缓存（304）
    >
    > 4. no-store：永远不要在客户端储存资源，永远都要去向服务器请求资源。
    ```txt
    Cache-control: max-age=3600
    ```

两者的最大区别就是，一个保存的是绝对时间，一个保存的是相对时间。Cache-control的可配置性比较强大。Cache-control的优先级也要高于Expires。

所以自从HTTP/1.1开始，Expires逐渐被Cache-control取代。

### **协商缓存**

当强制缓存失效之后，就需要使用协商缓存，由服务器决定缓存的内容是否失效。

**协商缓存流程**：

1. 浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个缓存标识请求服务器。

2. 如果响应了304状态码，就表示资源无更新，可以继续使用。

3. 如果资源更新了，服务器则会响应200状态码，并且响应一个新的数据和缓存规则，浏览器收到数据后再将规则写入到缓存数据库。

协商缓存是可以和强制缓存一起使用的，作为强制缓存失效后的一种备用方案。

**协商缓存由两组字段**：
- `Last-Modified` & `If-Modified-Since`
    > 流程：
    > 1. 服务器通过Last-Modified字段告诉客户端，资源最后一次被修改的时间。
    >
    > 2. 服务器将这个值和内容一起记录在缓存数据库中。
    >
    > 3. 下一次请求相同资源时，浏览器从自己的缓存中找出“不确定是否过期”的缓存。因此在请求头中将上次的Last-Modified的值写入到请求头的If-Modified-Since字段。
    >
    > 4. 服务器会将If-Modified-Since的值与Last-Modified字段进行比对。如果相等，就表示资源没有修改，响应304；反之表示资源修改了，响应200，并返回新的数据。
    >
    > 缺陷：
    >
    > - 如果资源更新的速度在秒一下的单位，那么该缓存无法使用，因为它记录的时间单位最低到秒。
    >
    > - 如果资源是通过服务器动态生成的，那么服务器响应的Last-Modified的时间一直是最新的生成时间，尽管文件可能没有发生变化，所以这种情况也起不到缓存作用。

- `Etag` & `If-None-Match`
    > 为了解决Last-Modified & If-Modified-Since的问题，HTTP/1.1出现了这一组字段。
    >
    > Etag字段存放的就是文件的特殊标识（一般都只是一个Hash值），服务器存储这文件的Etag字段。
    >
    > 流程跟Last-Modified & If-Modified-Since类似：
    >
    > - 浏览器下一次请求资源的时候，如果强缓存失效了，会将上一次的Etag的值放到请求头中的If-None-Match里，服务器比较If-None-Match跟最新的Etag是否相同，如果相同就响应304，否则响应200，并且返回最新资源。

## 缓存读取规则

当浏览器请求资源时：

1. 首先从Service Worker中获取资源（如果设置了Service Worker）
2. 查看Memory Cache
3. 查看Disk Cache
    - 如果有强缓存且没有失效，则使用强缓存，不请求服务器。状态码全是200。
    - 如果有强缓存但已经失效，使用协商缓存，比较后确定是304还是200。
4. 发送网络请求，等待响应。
5. 把响应内容存入Disk Cache（如果HTTP响应头信息有相应字段）
6. 把响应的内容存入Memory Cache（无视HTTP头信息的配置）
7. 将响应内容存入Service Worker的Cache Storage（如果设置了Service Worker）

针对以上第三步，具体的流程：
```txt
WHEN 浏览器请求资源时:
  IF 缓存存在:
    IF 强缓存未过期 (例如 Cache-Control 未过期):
      直接返回缓存资源 (状态码 200 from disk/memory cache)
    ELSE:
      # 发起协商缓存请求
      向服务器发送请求，携带以下请求头:
        If-None-Match: [缓存中的ETag]
        If-Modified-Since: [缓存中的Last-Modified]

      SWITCH (服务器响应状态码):
        CASE 304 Not Modified:
          更新缓存元信息
          继续使用缓存资源
        CASE 200 OK:
          更新缓存内容和标识
          返回新资源
        DEFAULT:
          处理其他状态码
  ELSE:
    # 缓存不存在，直接请求服务器
    向服务器发送请求
    如果响应可缓存，则存储到本地缓存
```


## 浏览器行为

用户对浏览器的不同操作，会触发不同的缓存读取策略。

主要有三种：
- **打开页面，地址栏输入地址**：查找Disk Cache中是否有命中的缓存。如果有就使用缓存，否则发送网络请求。

- **普通刷新（F5）**：因为TAB并没有关闭，所以Memory Cache是可用的，会被优先使用（如果命中了缓存），其次才是Disk Cache。

- **强制刷新（Ctrl+F5）**：浏览器不实用缓存，因此发送的请求头均带有Cache-control: no-cache（为了兼容还带了Pragma: no-cache）。服务器直接返回200和最新资源。
