## 什么是执行上下文？
简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。
每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

## 执行上下文的类型
JavaScript 中有三种执行上下文类型。

- **全局执行上下文** — 
这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。
它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。
一个程序中只会有一个全局执行上下文。

- **函数执行上下文** — 
每当一个函数被调用时, 都会为该函数创建一个新的上下文。
每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。
每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。

- **Eval 函数执行上下文** — 
执行在 eval 函数内部的代码也会有它属于自己的执行上下文。

## 执行栈

执行栈，也就是在其它编程语言中所说的“调用栈”，
是一种拥有 LIFO（后进先出）数据结构的栈，
被用来存储代码运行时创建的所有执行上下文。

当 JavaScript 引擎第一次遇到你的脚本时，
它会创建一个全局的执行上下文并且压入当前执行栈。
每当引擎遇到一个函数调用，
它会为该函数创建一个新的执行上下文并压入栈的顶部。
引擎会执行那些执行上下文位于栈顶的函数。

当该函数执行结束时，
执行上下文从栈中弹出，
控制流程到达当前栈中的下一个上下文。

## 执行上下文的创建过程

创建执行上下文有两个阶段：
1. 创建阶段
2. 执行阶段（也就是代码运行过程，这里不解释）

### 创建阶段

在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：
1. this 值的决定，即我们所熟知的 This 绑定（这里不解释）
2. 创建词法环境组件
3. 创建变量环境组件

#### 词法环境
简单来说词法环境是一种持有标识符—变量映射的结构。  
这里的标识符指的是变量/函数在**栈内存中**的函数名字，  
而变量是对在**堆内存中**的实际对象[包含函数类型对象]或原始数据的引用。

现在，在词法环境的内部有两个组件：
1. 环境记录器
2. 一个外部环境的引用

环境记录器是存储变量和函数声明的实际位置。
**外部环境的引用**，**指向创建它的上下文**，意味着它可以访问其父级词法环境（作用域）。

**词法环境有两种类型**：

- 全局环境（在全局执行上下文中）是没有外部环境引用的词法环境。
全局环境的外部环境引用是 null。
它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象） 还有任何用户定义的全局变量，
并且 this 的值指向全局对象。

- 函数环境中，函数内部用户定义的变量存储在环境记录器中。
并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

**环境记录器也有两种类型**（如上！）：
声明式环境记录器存储变量、函数和参数。  
对象环境记录器用来定义出现在全局上下文中的变量和函数的关系。

简而言之，  
在全局环境中，环境记录器是对象环境记录器。  
在函数环境中，环境记录器是声明式环境记录器。

**注意** — 
对于函数环境，
声明式环境记录器还包含了一个传递给函数的 arguments 对象 （此对象存储索引和参数的映射）
和传递给函数的参数的 length。

#### 变量环境

它同样是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。
如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。
在 ES6 中，词法环境组件和变量环境的一个不同：
前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。


## 作用域链
代码在运行时，会创建一个**全局上下文**压入执行栈底部，  
在这个全局上下文的创建过程中：  

首先**绑定 this 的指向**（指向全局/global/window）  

然后**绑定词法环境**：  
这个过程中，JS 引擎首先会将在全局的**声明**的函数保存到环境中，也就是在环境中**绑定了函数名以及函数地址**，
并且在**堆内存中的函数本身**会保留一个`[[scopes]]`的引用，指向创建它的上下文对象（这里是全局上下文）  
除此之外，JS 引擎还会绑定全局声明的 let 和 const 的变量名，并将这些变量状态设置为`未初始化（uninitialized）`  
然后**绑定变量环境**：  
这时候 JS 引擎会绑定使用`var`声明的变量名，并将他们的状态赋值为`undefined`

当全局上下文中声明的函数被调用时，也会创建一个函数上下文，加入执行栈中  
然后跟全局上下文的创建过程相同：  
首先绑定 this 指向，到绑定词法环境，到绑定变量环境  
但这里绑定的是在当前函数作用域下声明的函数和变量
并且在词法环境中还会绑定记录参数的`arguments`对象和传递给参数的`length`

在函数运行过程中，
如果需要读取变量，
首先会从当前的函数上下文的环境对象中（词法环境和变量环境）寻找变量，
如果找不到，则通过函数本身的`[[scopes]]`引用，找到声明了这个函数的上下文的环境对象，
再试图寻找变量，如果再找不到，则继续查找这个创建这个函数上下文的函数，
并通过其本身的`[[scopes]]`，继续找到声明了这个函数的上下文的环境对象，
直到找到全局上下文的环境对象，如果再没有就报错。  
这也就是**作用域链**

函数运行结束后，这个函数上下文就会弹出执行栈

示例代码：
```js
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);
```

其执行上下文用伪代码表示：
```js
GlobalExectionContext = {

  ThisBinding: [Global Object],

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: [ uninitialized ],
      b: [ uninitialized ],
      multiply: [ func ]
    }
    outer: [null]
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,
    }
    outer: [null]
  }
}

FunctionExectionContext: {
  ThisBinding: [Global Object],

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},
    },
    // 指向创建这这个上下文的函数的 [[scopes]] 引用
    // 函数的 [[scopes]] 引用指向声明这个函数的上下文
    // 也就是可以通过 [[scopes]] 引用找到其父级作用域
    outer: [GlobalLexicalEnvironment] 
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      g: undefined
    },
    // 指向创建这这个上下文的函数的 [[scopes]] 引用
    outer: [GlobalLexicalEnvironment]
  }
}
```
